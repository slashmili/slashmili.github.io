---
layout: post
title: "Why Elixir is Awesome?"
date: 2016-02-06 09:33
comments: false
categories:
  - elixir
  - lang
  - otp
---

It was almost a year ago that I got introduced to [Elixir](http://elixir-lang.org).
I remember my first impression was yet another language on top of another one.
In addition running a software on [Erlang/OTP](http://www.erlang.org/), it's totally different beast,
so I was a bit skeptical it. However I gave it a chance and after a year,
I'm totally happy with the time I spend and
I believe that every one should take advantage of the language and the platform that is running on.


## Why Elixir?

<!-- more -->
### Elegant & Expressive

```elixir
urls = ["http://google.com", "http://trello.com"]
random_url = urls |> Enum.shuffle |> List.first
```

Do I need to explain the code? Don't think so!
And if you have a bit of unix background this code should make sense to you.

> <small>Note: yes, there is an easy way to get random item(`Enum.random`), the above code is just for making the point.</small>

BTW did I tell you Elixir is a functional programming language?
If you are not familiar with functional programming, it might take sometime to get to use
to that, after you un-learn your OOP skills, you'll find that every thing make sense in Elixir land.

### Mature Environment
The tools that are available in Elixir environment are necessity of software development:

* [Hex](https://hex.pm/) is a package manager that is done right.
* [Mix](http://elixir-lang.org/docs/stable/mix/Mix.html) is a build tool to run your tasks.
* [ExUnit](http://elixir-lang.org/docs/stable/ex_unit/ExUnit.html) is your unit testing framework.
* [ExDoc](https://github.com/elixir-lang/ex_doc) generates documentation for your Elixir projects.
* [Erlang/OTP](https://www.erlang.org/) has been [around us](https://www.quora.com/Which-companies-use-the-Erlang-language) for quite some time. IMO Erlang's syntax has been a barrier to be widespread amoung developers.


### Metaprogramming
Whenever I'm learning a new language, after I get enough familiar with the language and it's syntax the first thing
I'm looking for is how can I write a code that writes code for me!

The way that elixir does that is pretty unique. Elixir's
[AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) can be represented by Elixir's own data
structures. Having the AST accessible by normal Elixir code lets you do very powerful
things because you can operate at the level typically reserved only for compilers and language designers.

Let's say you want to humanize a mathematical equation, the interface and output should be like this:

```elixir
iex > Math.say 1 + 2
1 plus 2 is 3
3
iex > Math.say 5 + 7
5 plus 7 is 12
12
```

To achieve that we need to write a `macro` that matches with AST of `1 + 2`.
Thanks to Elixir's `quote` function it's easy to find out how it looks like:

```elixir
iex > quote do: 1 + 2
{:+, [context: Elixir, import: Kernel], [1, 2]}
```

Now that we know how `1 + 2` is represented in Elixir's format we can write a `defmacro` that
matches with that data:

```elixir
defmodule Math do
  defmacro say({:+, _, [lhs, rhs]}) do
    quote do
      lhs = unquote lhs
      rhs = unquote rhs
      result = lhs + rhs
      IO.puts "#{lhs} plus #{rhs} is #{result}"
      result
    end
  end
end
```

You can read more about macros in
[Metaprogramming Elixir](https://pragprog.com/book/cmelixir/metaprogramming-elixir) book.

> <small>Note: this example is from the same book</small>

I have to mention that
[if](http://elixir-lang.org/docs/master/elixir/Kernel.html#if/2) and most of the Elixir's keywords
are implemented as a `macro`.

### Concurrent
Having a concurrent system in Elixir is inevitable. In addition because the data
are immutable you don't need to worry about concurrent processes stepping on each others toes.
Elixir achieves that by running on top of Erlang Virtual Machine (BEAM).

How does it work? Let's say you want run a few queries and send the results back to the user

```elixir
iex > run_query = fn (query) ->
  1000
  |> :random.uniform
  |> :timer.sleep
  IO.inspect "query #{query} executed"
end
```
> <small> Not all the queries finish in the same time, to simulate that we sleep random amount of time</small>

It would be nice to run independent queries concurrently, let's try it in `iex`:

```elixir
iex > spawn(fn -> run_query.('select * from users') end)
#PID<0.132.0>
iex > spawn(fn -> run_query.('select * from reports') end)
#PID<0.134.0>
"query select * from users executed"
"query select * from reports executed"
```

As you can see both queries executed concurrently.
> <small>Just a quick reminder, when I say these two queries ran concurrently it doesn't mean that they ran in the same time.
> However since my Macbook has 8 processors I had the leverage of running the queries in the same time.</small>

You might ask how can I get back the results and use them on the main process? The answer is *Message Passing*.

```elixir
iex > caller = send
iex > spawn(fn -> send(caller, {:query_result, run_query.('select * from reports')}) end)
#PID<0.138.0>
"query select * from reports executed"
iex > receive do
    {:query_result, result} -> IO.inspect "result is #{result}"
    end
"result is query select * from reports executed"
"result is query select * from reports executed"
```

The processes in Elixir(it's not same as unix processe) can talk to each other through message.
Each process has it's own mailbox and can process one item at a time.

> <small> When you want to write production grade application, you'll find yourself using
> [OTP](https://en.wikipedia.org/wiki/Open_Telecom_Platform) framework.</small>

### Distributed
...

> You may wanna to take look at my presentation slides [Elixir @klxrb June 2015](https://github.com/slashmili/talks/tree/master/2015/elixir-klxrb-june)
